using Cxx
module CxxROOT

using Cxx
import CxxStd

const ROOT_PATH = "/Users/kfischer/Projects/root/"
const ROOT_OBJ_DIR = joinpath(ROOT_PATH,"obj-debug")

function __init__1()
    addHeaderDir(joinpath(ROOT_PATH,"core/base/inc"),kind=C_System)
    addHeaderDir(joinpath(ROOT_PATH,"core/meta/inc"),kind=C_System)
    addHeaderDir(joinpath(ROOT_PATH,"core/metautils/inc"),kind=C_System)
    addHeaderDir(joinpath(ROOT_PATH,"core/meta/src"),kind=C_System)
    addHeaderDir(joinpath(ROOT_PATH,"interpreter/cling/include"),kind=C_System)
    addHeaderDir(joinpath(ROOT_PATH,"interpreter/"),kind=C_System)
    addHeaderDir(joinpath(ROOT_OBJ_DIR,"include"),kind=C_System)
    Libdl.dlopen(joinpath(ROOT_OBJ_DIR,"lib/libCore.so"), Libdl.RTLD_GLOBAL | Libdl.RTLD_LAZY)
    cxx"""
        // For hardcoded friend classes
        #define TCling TCxx
        #include "TROOT.h"
        #include "TInterpreter.h"
        #include "TSystem.h"
        #include "TClass.h"
        #include "TBaseClass.h"
        #include "TApplication.h"
        #include "TPluginManager.h"
        #include "TMemberInspector.h"
        #include "TDataMember.h"
        #include "clang/AST/ASTContext.h"
        #include "clang/Sema/Lookup.h"
        #include "clang/AST/CXXInheritance.h"
        #include "clang/AST/RecordLayout.h"
        #include "cling/Interpreter/Interpreter.h"
        #include "cling/lib/Interpreter/DeclCollector.h"
        #include "cling/Interpreter/LookupHelper.h"
        #include "cling/Interpreter/Value.h"
        #include "cling/Interpreter/CompilationOptions.h"
        #include "cling/Interpreter/ClangInternalState.h"
        #include <iostream>
    """
    cxxinclude(joinpath(dirname(@__FILE__),"TCxx.cxx"))
end
__init__1()

cxx"""

namespace cling {
    Interpreter::Interpreter(int argc, const char* const *argv, const char* llvmdir, bool noRuntime) {
        m_LookupHelper.reset(new LookupHelper($:(Cxx.instance(Cxx.__default_compiler__).Parser::pcpp"clang::Parser"),this));
    }
    Interpreter::~Interpreter() {}

    const InvocationOptions& Interpreter::getOptions() const { return m_Opts; }
    InvocationOptions& Interpreter::getOptions() { return m_Opts; }

    const llvm::LLVMContext* Interpreter::getLLVMContext() const { assert(false); }

    llvm::LLVMContext* Interpreter::getLLVMContext() { assert(false); }

    const LookupHelper& Interpreter::getLookupHelper() const
        { return *m_LookupHelper; }

    ///\brief Returns the next available valid free source location.
    ///
    clang::SourceLocation Interpreter::getNextAvailableLoc() const { return clang::SourceLocation(); }

    ///\brief true if -fsyntax-only flag passed.
    ///
    bool Interpreter::isInSyntaxOnlyMode() const { assert(false); }

    ///\brief Creates unique name that can be used for various aims.
    ///
    void Interpreter::createUniqueName(std::string& out) { assert(false); }

    ///\brief Checks whether the name was generated by Interpreter's unique name
    /// generator.
    ///
    ///\param[in] name - The name being checked.
    ///
    ///\returns true if the name is generated.
    ///
    bool Interpreter::isUniqueName(llvm::StringRef name) { assert(false); }

    ///\brief Super efficient way of creating unique names, which will be used
    /// as a part of the compilation process.
    ///
    /// Creates the name directly in the compiler's identifier table, so that
    /// next time the compiler looks for that name it will find it directly
    /// there.
    ///
    llvm::StringRef Interpreter::createUniqueWrapper() { assert(false); }

    ///\brief Checks whether the name was generated by Interpreter's unique
    /// wrapper name generator.
    ///
    ///\param[in] name - The name being checked.
    ///
    ///\returns true if the name is generated.
    ///
    bool Interpreter::isUniqueWrapper(llvm::StringRef name) { assert(false); }

    ///\brief Prints the current include paths that are used.
    ///
    ///\param[out] incpaths - Pass in a llvm::SmallVector<std::string, N> with
    ///       sufficiently sized N, to hold the result of the call.
    ///\param[in] withSystem - if true, incpaths will also contain system
    ///       include paths (framework, STL etc).
    ///\param[in] withFlags - if true, each element in incpaths will be prefixed
    ///       with a "-I" or similar, and some entries of incpaths will signal
    ///       a new include path region (e.g. "-cxx-isystem"). Also, flags
    ///       defining header search behavior will be included in incpaths, e.g.
    ///       "-nostdinc".
    void Interpreter::GetIncludePaths(llvm::SmallVectorImpl<std::string>& incpaths,
                         bool withSystem, bool withFlags) { assert(false); }

    ///\brief Prints the current include paths that are used.
    ///
    void Interpreter::DumpIncludePath() { assert(false); }

    ///\brief Store the interpreter state in files
    /// Store the AST, the included files and the lookup tables
    ///
    ///\param[in] name - The name of the files where the state will
    /// be printed
    ///
    void Interpreter::storeInterpreterState(const std::string& name) const { assert(false); }

    ///\brief Compare the actual interpreter state with the one stored
    /// previously.
    ///
    ///\param[in] name - The name of the previously stored file
    ///
    void Interpreter::compareInterpreterState(const std::string& name) const { assert(false); }

    ///\brief Print the included files in a temporary file
    ///
    ///\param[in] out - The output stream to be printed into.
    ///
    void Interpreter::printIncludedFiles (llvm::raw_ostream& out) const { assert(false); }

    ///\brief Compiles the given input.
    ///
    /// This interface helps to run everything that cling can run. From
    /// declaring header files to running or evaluating single statements.
    /// Note that this should be used when there is no idea of what kind of
    /// input is going to be processed. Otherwise if is known, for example
    /// only header files are going to be processed it is much faster to run the
    /// specific interface for doing that - in the particular case - declare().
    ///
    ///\param[in] input - The input to be compiled.
    ///\param[in,out] V - The result of the evaluation of the input. Must be
    ///       initialized to point to the return value's location if the
    ///       expression result is an aggregate.
    ///\param[out] T - The cling::Transaction of the compiled input.
    ///
    ///\returns Whether the operation was fully successful.
    ///
    Interpreter::CompilationResult Interpreter::process(const std::string& input, Value* V,
                              Transaction** T) { assert(false); }

    ///\brief Parses input line, which doesn't contain statements. No code
    /// generation is done.
    ///
    /// Same as declare without codegening. Useful when a library is loaded and
    /// the header files need to be imported.
    ///
    ///\param[in] input - The input containing the declarations.
    ///\param[out] T - The cling::Transaction of the parsed input.
    ///
    ///\returns Whether the operation was fully successful.
    ///
    Interpreter::CompilationResult Interpreter::parse(const std::string& input,
                            Transaction** T) const { assert(false); }

    ///\brief Looks for a already generated PCM for the given header file and
    /// loads it.
    ///
    ///\param[in] headerFile - The header file for which a module should be
    ///                        loaded.
    ///
    ///\returns Whether the operation was fully successful.
    ///
    Interpreter::CompilationResult Interpreter::loadModuleForHeader(const std::string& headerFile) { assert(false); }

    ///\brief Compiles input line, which contains only expressions.
    ///
    /// The interface circumvents the most of the extra work necessary extract
    /// the declarations from the input.
    ///
    /// @param[in] input - The input containing only expressions
    /// @param[in,out] V - The value of the executed input. Must be
    ///       initialized to point to the return value's location if the
    ///       expression result is an aggregate.
    ///
    ///\returns Whether the operation was fully successful.
    ///
    Interpreter::CompilationResult Interpreter::evaluate(const std::string& input, Value& V)
      { assert(false); }

    ///\brief Compiles input line and runs.
    ///
    /// The interface is the fastest way to compile and run a statement or
    /// expression. It just wraps the input and runs the wrapper, without any
    /// other "magic"
    ///
    /// @param[in] input - The input containing only expressions.
    ///
    ///\returns Whether the operation was fully successful.
    ///
    Interpreter::CompilationResult Interpreter::execute(const std::string& input)
      { assert(false); }

    ///\brief Generates code for all Decls of a transaction.
    ///
    /// @param[in] T - The cling::Transaction that contains the declarations and
    ///                the compilation/generation options. Takes ownership!
    ///
    ///\returns Whether the operation was fully successful.
    ///
    Interpreter::CompilationResult Interpreter::emitAllDecls(Transaction* T)
      { assert(false); }

    ///\brief Looks up a file or library according to the current interpreter
    /// include paths and system include paths.
    ///\param[in] file - The name of the file.
    ///
    ///\returns the canonical path to the file or library or empty string if not
    /// found.
    ///
    std::string Interpreter::lookupFileOrLibrary(llvm::StringRef file)
    {

        const clang::FileEntry* FE = 0;

        //Copied from clang's PPDirectives.cpp
        bool isAngled = false;
        // Clang doc says:
        // "LookupFrom is set when this is a \#include_next directive, it
        // specifies the file to start searching from."
        const clang::DirectoryLookup* FromDir = 0;
        const clang::FileEntry* FromFile = 0;
        const clang::DirectoryLookup* CurDir = 0;
        clang::Preprocessor& PP = getCI()->getPreprocessor();
        // PP::LookupFile uses it to issue 'nice' diagnostic
        clang::SourceLocation fileNameLoc;
        FE = PP.LookupFile(fileNameLoc, file, isAngled, FromDir, FromFile,
                           CurDir, /*SearchPath*/0, /*RelativePath*/ 0,
                           /*suggestedModule*/0, /*SkipCache*/false,
                           /*OpenFile*/ false, /*CacheFail*/ false);
        if (FE)
          return FE->getName();
        return file;

    }

    ///\brief Unloads (forgets) given number of transactions.
    ///
    ///\param[in] numberOfTransactions - how many transactions to revert
    ///                                  starting from the last.
    ///
    void Interpreter::unload(unsigned numberOfTransactions) { assert(false); }

    bool Interpreter::isPrintingDebug() const { assert(false); }
    void Interpreter::enablePrintDebug(bool print) { assert(false); }

    void Interpreter::enableDynamicLookup(bool value) { }
    bool Interpreter::isDynamicLookupEnabled() const { return false; }

    bool Interpreter::isRawInputEnabled() const { assert(false); }
    void Interpreter::enableRawInput(bool raw) { assert(false); }

    //FIXME: This must be in InterpreterCallbacks.
    void Interpreter::installLazyFunctionCreator(void* (*fp)(const std::string&)) { }

    //FIXME: Terrible hack to let the IncrementalParser run static inits on
    // transaction completed.
    Interpreter::ExecutionResult Interpreter::executeTransaction(Transaction& T) { assert(false); }

    ///\brief Evaluates given expression within given declaration context.
    ///
    ///\param[in] expr - The expression.
    ///\param[in] DC - The declaration context in which the expression is going
    ///                to be evaluated.
    ///\param[in] ValuePrinterReq - Whether the value printing is requested.
    ///
    ///\returns The result of the evaluation if the expression.
    ///
    cling::Value Interpreter::Evaluate(const char* expr, clang::DeclContext* DC,
                            bool ValuePrinterReq) { assert(false); }

    ///\brief Interpreter callbacks accessors.
    /// Note that this class takes ownership of any callback object given to it.
    ///
    void Interpreter::setCallbacks(std::unique_ptr<InterpreterCallbacks> C) { }
    const InterpreterCallbacks* Interpreter::getCallbacks() const {assert(false);}
    InterpreterCallbacks* Interpreter::getCallbacks() { assert(false); }

    const DynamicLibraryManager* Interpreter::getDynamicLibraryManager() const {
      return nullptr;
    }
    DynamicLibraryManager* Interpreter::getDynamicLibraryManager() {
      return nullptr;
    }

    const Transaction* Interpreter::getFirstTransaction() const { return nullptr; }
    const Transaction* Interpreter::getLastTransaction() const { return nullptr; }
    const Transaction* Interpreter::getCurrentTransaction() const { return nullptr; }

    ///\brief Gets the address of an existing global and whether it was JITted.
    ///
    /// JIT symbols might not be immediately convertible to e.g. a function
    /// pointer as their call setup is different.
    ///
    ///\param[in]  D       - the global's Decl to find
    ///\param[out] fromJIT - whether the symbol was JITted.
    void* Interpreter::getAddressOfGlobal(const clang::GlobalDecl& D,
                             bool* fromJIT) const
    { assert(false); }

    ///\brief Gets the address of an existing global and whether it was JITted.
    ///
    /// JIT symbols might not be immediately convertible to e.g. a function
    /// pointer as their call setup is different.
    ///
    ///\param[in]  SymName - the name of the global to search
    ///\param[out] fromJIT - whether the symbol was JITted.
    ///
    void* Interpreter::getAddressOfGlobal(llvm::StringRef SymName, bool* fromJIT) const
    { assert(false); }

    ///\brief Add an atexit function.
    ///
    ///\param[in] Func - Function to be called.
    ///\param[in] Arg - argument passed to the function.
    ///
    void Interpreter::AddAtExitFunc(void (*Func) (void*), void* Arg)
    { assert(false); }

    ///\brief Forwards to cling::IncrementalExecutor::addModule.
    ///
    void Interpreter::addModule(llvm::Module* module)
    { assert(false); }

    void Interpreter::GenerateAutoloadingMap(llvm::StringRef inFile, llvm::StringRef outFile,
                                bool enableMacros, bool enableLogs)
    { assert(false); }

    void Interpreter::forwardDeclare(Transaction& T, clang::Sema& S,
                        llvm::raw_ostream& out,
                        bool enableMacros,
                        llvm::raw_ostream* logs) const
    { assert(false); }

  Interpreter::PushTransactionRAII::PushTransactionRAII(const Interpreter* i) { }

  Interpreter::PushTransactionRAII::~PushTransactionRAII() {  }

  void Interpreter::PushTransactionRAII::pop() const {  }

  Interpreter::StateDebuggerRAII::StateDebuggerRAII(const Interpreter* i)
    : m_Interpreter(i) { }

  Interpreter::StateDebuggerRAII::~StateDebuggerRAII() {  }

  void Interpreter::StateDebuggerRAII::pop() const {}

}


"""

Libdl.dlopen(joinpath(ROOT_OBJ_DIR,"lib/libCling.so"), Libdl.RTLD_GLOBAL | Libdl.RTLD_LAZY)
DC = icxx"new cling::DeclCollector();"
icxx"""
$DC->setTransaction(new cling::Transaction($(Cxx.instance(Cxx.__default_compiler__).CI)->getSema()));
"""
Cxx.addASTConsumer(Cxx.instance(Cxx.__default_compiler__),icxx"return static_cast<clang::ASTConsumer*>($DC);")


#=
///\brief Shows the current version of the project.
///
///\returns The current svn revision (svn Id).
///
=#
@cxxm "const char* cling::Interpreter::getVersion() const" begin
    pointer("Cxx.jl with Julia v$VERSION")
end

#=
\brief Compile extern "C" function and return its address.

\param[in] name - function name
\param[in] code - function definition, must contain 'extern "C"'
\param[in] ifUniq - only compile this function if no function
 with the same name exists, else return the existing address
\param[in] withAccessControl - whether to enforce access restrictions

\returns the address of the function or 0 if the compilation failed.
=#
@cxxm "void *cling::Interpreter::compileFunction(llvm::StringRef name, llvm::StringRef code,
                      bool ifUniq, bool withAccessControl)" begin
  Cxx.cxxparse(bytestring(code))
  name = bytestring(name)
  ptr = eval(Cxx.process_cxx_string("return (void*)&$name;", false, false, :REPL, 1, 1;
    compiler = Cxx.__default_compiler__))
  @show ptr
  ptr
end

#=
\brief Adds an include path (-I).

=#
@cxxm "void cling::Interpreter::AddIncludePath(llvm::StringRef incpath)" begin
    Cxx.addHeaderDir(bytestring(incpath))
end

@cxxm "clang::CompilerInstance* cling::Interpreter::getCI() const" begin
    Cxx.instance(Cxx.__default_compiler__).CI
end

@cxxm "clang::Sema& cling::Interpreter::getSema() const" begin
    icxx"$(Cxx.instance(Cxx.__default_compiler__).CI)->getSema();"
end

@cxxm "const clang::Parser& cling::Interpreter::getParser() const" begin
    icxx"*$(Cxx.instance(Cxx.__default_compiler__).Parser);"
end

@cxxm "clang::Parser& cling::Interpreter::getParser()" begin
    icxx"*$(Cxx.instance(Cxx.__default_compiler__).Parser);"
end

#=
\brief Compiles input line, which doesn't contain statements.

 The interface circumvents the most of the extra work necessary to
 compile and run statements.

 @param[in] input - The input containing only declarations (aka
                    Top Level Declarations)
 @param[out] T - The cling::Transaction of the input

\returns Whether the operation was fully successful.
=#
@cxxm "cling::Interpreter::CompilationResult cling::Interpreter::declare(const std::string& input, Transaction** T)" begin
    NewT = icxx"new cling::Transaction($(Cxx.instance(Cxx.__default_compiler__).CI)->getSema());"
    icxx"$DC->setTransaction($NewT);"
    Cxx.cxxparse(bytestring(input))
    icxx"""
        if ($T)
            *$T = $NewT;
        return cling::Interpreter::kSuccess;
    """
end

#=
\brief Parses input line, which doesn't contain statements. Code
 generation needed to make the module functional.

 Same as declare without most of the codegening.  Only a few
 things, like inline function are codegened.  Useful when a
 library is loaded and the header files need to be imported.

\param[in] input - The input containing the declarations.

\returns Whether the operation was fully successful.
=#
@cxxm "cling::Interpreter::CompilationResult cling::Interpreter::parseForModule(const std::string& input)" begin
    Cxx.cxxparse(bytestring(input))
    icxx"return cling::Interpreter::kSuccess;"
end

#=
\brief Loads header file or shared library.

\param [in] filename - The file to loaded.
\param [in] allowSharedLib - Whether to try to load the file as shared
                             library.
\param [out] T -  Transaction containing the loaded file.
\returns result of the compilation.

=#
@cxxm "cling::Interpreter::CompilationResult cling::Interpreter::loadFile(const std::string& filename,
                           bool allowSharedLib,
                           Transaction** T)" begin
    @show bytestring(filename)
    if !allowSharedLib || Libdl.dlopen_e(bytestring(filename)) == C_NULL
        NewT = icxx"new cling::Transaction($(Cxx.instance(Cxx.__default_compiler__).CI)->getSema());"
        icxx"$DC->setTransaction($NewT);"
        Cxx.cxxinclude(bytestring(filename))
        icxx"""
            if ($T)
                *$T = $NewT;
        """
    end
    icxx"return cling::Interpreter::kSuccess;"
end

#=
\brief Compiles input line, which contains only expressions and prints
 out the result of its execution.

 The interface circumvents the most of the extra work necessary extract
 the declarations from the input.

 @param[in] input - The input containing only expressions.
 @param[in,out] V - The value of the executed input. Must be
       initialized to point to the return value's location if the
       expression result is an aggregate.

\returns Whether the operation was fully successful.
=#
@cxxm "cling::Interpreter::CompilationResult cling::Interpreter::echo(const std::string& input, Value* V)" begin
    @show bytestring(input)
    ret = eval(Cxx.process_cxx_string(string(bytestring(input),"\n;"), false, false, :REPL, 1, 1;
    compiler = Cxx.__default_compiler__))
    icxx"return cling::Interpreter::kSuccess;"
end

using DyldExport
classes = [pcpp"clang::CXXRecordDecl"(Cxx.lookup_name(Cxx.instance(Cxx.__default_compiler__),x).ptr) for x in Any[
    ["cling","Interpreter"],
    ["cling","Interpreter","PushTransactionRAII"],
    ["cling","Interpreter","StateDebuggerRAII"]
]]

DyldExport.export_class(classes)

#__init__2() = 
#__init__2()

end # module
using Cxx
